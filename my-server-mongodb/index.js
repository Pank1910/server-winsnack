const express = require('express');
const app = express();
const port = 5000;
const morgan = require("morgan");
const bodyParser = require("body-parser");
const cors = require("cors");
const { MongoClient, ObjectId } = require('mongodb');
const multer = require('multer');
const path = require('path');
const fs = require('fs');

app.use(morgan("combined"));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());


const uri = "mongodb+srv://thanhtylenguyen:WinSnack2025@webcluster.9rruw.mongodb.net/";
const client = new MongoClient(uri);


async function connectDB() {
    try {
        await client.connect();
        console.log("‚úÖ Connected to MongoDB successfully!");
        const database = client.db("winsnack");
        const collections = await database.listCollections().toArray();
        console.log("üìÇ Collections in database:", collections.map(col => col.name));
    } catch (error) {
        console.error("‚ùå MongoDB connection error:", error);
    }
}


connectDB();


const database = client.db("winsnack");
const winsnackCollection = database.collection("Cart");
const productsCollection = database.collection("Product");
const orderCollection = database.collection("Order"); // ‚úÖ Th√™m collection Order


// Trang ch·ªß test server
app.get("/", (req, res) => {
    res.send("This Web server is processed for MongoDB");
});


// Check DB v√† test collection
app.get("/check-db", async (req, res) => {
    try {
        const collections = await database.listCollections().toArray();
        const collectionNames = collections.map(col => col.name);
       
        if (!collectionNames.includes("Cart")) {
            return res.status(404).json({
                success: false,
                message: "‚ùå Collection 'Cart' does not exist!"
            });
        }


        const sampleDoc = await winsnackCollection.findOne({});
        res.json({
            success: true,
            message: "‚úÖ MongoDB connected successfully!",
            sampleDocument: sampleDoc || "No documents found in CARTS collection",
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå MongoDB connection failed",
            error: error.toString(),
        });
    }
});


// ‚úÖ Endpoint l·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m
app.get("/products", async (req, res) => {
    try {
        const products = await productsCollection.find({}).toArray();
        res.json({
            success: true,
            data: products,
            count: products.length
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch products",
            error: error.toString()
        });
    }
});


// ‚úÖ Endpoint l·∫•y s·∫£n ph·∫©m theo ID
app.get("/products/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const product = await productsCollection.findOne({ _id: id });
        if (!product) {
            return res.status(404).json({
                success: false,
                message: "‚ùå Product not found"
            });
        }
       
        res.json({
            success: true,
            data: product
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch product",
            error: error.toString()
        });
    }
});

// ‚úÖ Endpoint t√¨m ki·∫øm s·∫£n ph·∫©m
app.get("/products/search", async (req, res) => {
    try {
        const { term } = req.query;
        
        if (!term) {
            return res.json({
                success: true,
                data: [],
                count: 0
            });
        }

        // T·∫°o pattern t√¨m ki·∫øm kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng
        const searchPattern = new RegExp(term, 'i');
        
        // T√¨m ki·∫øm s·∫£n ph·∫©m theo t√™n
        const products = await productsCollection.find({
            $or: [
                { product_name: searchPattern },
                // { category: searchPattern }
            ]
        }).toArray();
        
        res.json({
            success: true,
            data: products,
            count: products.length
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to search products",
            error: error.toString()
        });
    }
});

// Gi·∫£ s·ª≠ usersCollection ƒë√£ ƒë∆∞·ª£c khai b√°o t·ª´ tr∆∞·ªõc
const usersCollection = database.collection("User");


// API c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ ng∆∞·ªùi d√πng
app.put('/addresses/update', async (req, res) => {
    try {
        const { userId, profileName, phone, address } = req.body;


        // Ki·ªÉm tra userId c√≥ t·ªìn t·∫°i kh√¥ng
        const user = await usersCollection.findOne({ userId: userId });


       
        if (!user) {
            return res.status(404).json({
                message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i"
            });
        }


        // C·∫≠p nh·∫≠t th√¥ng tin ƒë·ªãa ch·ªâ
        const result = await usersCollection.findOneAndUpdate(
            { userId: userId },
            {
                $set: {
                    profileName: profileName,
                    phone: phone,
                    address: address
                }
            },
            { returnDocument: 'after' }
        );


        res.json({
            profileName: result.profileName,
            phone: result.phone,
            address: result.address
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ",
            error: error.toString()
        });
    }
});


// API l·∫•y ƒë·ªãa ch·ªâ ng∆∞·ªùi d√πng
app.get('/addresses/user', async (req, res) => {
    try {
        const userId = req.query.userId;


        const user = await usersCollection.findOne(
            { userId: userId },
            { projection: { profileName: 1, phone: 1, address: 1 } }
        );


        if (!user) {
            return res.status(404).json({
                message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i"
            });
        }


        res.json({
            profileName: user.profileName || "",
            phone: user.phone || "",
            address: user.address || ""
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói l·∫•y ƒë·ªãa ch·ªâ",
            error: error.toString()
        });
    }
});


// Th√™m cart v√†o file index.js
const cartCollection = database.collection("Cart");


app.post('/carts/add', async (req, res) => {
    try {
        const cartItem = req.body;
       
        // Ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√£ t·ªìn t·∫°i trong gi·ªè h√†ng ch∆∞a
        const existingItem = await cartCollection.findOne({
            productId: cartItem.productId,
            userId: cartItem.userId
        });


        if (existingItem) {
            // N·∫øu ƒë√£ t·ªìn t·∫°i, c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
            const result = await cartCollection.findOneAndUpdate(
                {
                    productId: cartItem.productId,
                    userId: cartItem.userId
                },
                { $inc: { quantity: cartItem.quantity } },
                { returnDocument: 'after' }
            );
            res.json(result);
        } else {
            // N·∫øu ch∆∞a t·ªìn t·∫°i, th√™m m·ªõi
            const result = await cartCollection.insertOne(cartItem);
            res.status(201).json({
                ...cartItem,
                _id: result.insertedId
            });
        }
    } catch (error) {
        res.status(500).json({
            message: "L·ªói th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng",
            error: error.toString()
        });
    }
});


app.get('/cart/items', async (req, res) => {
    try {
        const userId = req.query.userId;
        console.log(`ƒêang t√¨m c√°c m·ª•c gi·ªè h√†ng cho ng∆∞·ªùi d√πng: ${userId}`);
        const cartItems = await cartCollection.find({ userId }).toArray();
        console.log(`T√¨m th·∫•y ${cartItems.length} m·ª•c gi·ªè h√†ng`);
        res.json(cartItems);
    } catch (error) {
        console.error("L·ªói khi l·∫•y c√°c m·ª•c gi·ªè h√†ng:", error);
        res.status(500).json({
            message: "L·ªói l·∫•y danh s√°ch s·∫£n ph·∫©m trong gi·ªè h√†ng",
            error: error.toString()
        });
    }
});


app.patch('/cart/update/:productId', async (req, res) => {
    try {
        const productId = req.params.productId;
        const userId = req.query.userId;
        const { quantity } = req.body;


        const result = await cartCollection.findOneAndUpdate(
            {
                productId: productId,
                userId: userId
            },
            { $set: { quantity: quantity } },
            { returnDocument: 'after' }
        );


        res.json(result);
    } catch (error) {
        res.status(500).json({
            message: "L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m",
            error: error.toString()
        });
    }
});


app.delete('/cart/remove/:productId', async (req, res) => {
    try {
        const productId = req.params.productId;
        const userId = req.query.userId;


        const result = await winsnackCollection.deleteOne({
            productId: productId,
            userId: userId
        });
       
        res.json({
            message: "ƒê√£ x√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng",
            deletedCount: result.deletedCount
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói x√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng",
            error: error.toString()
        });
    }
});


app.delete('/cart/clear', async (req, res) => {
    try {
        const userId = req.query.userId;


        const result = await cartCollection.deleteMany({ userId });
       
        res.json({
            message: "ƒê√£ x√≥a to√†n b·ªô gi·ªè h√†ng",
            deletedCount: result.deletedCount
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói x√≥a gi·ªè h√†ng",
            error: error.toString()
        });
    }
});




// Note: Th√™m endpoint ƒë·ªÉ l·∫•y gi·ªè h√†ng c·ªßa ng∆∞·ªùi d√πng
app.get("/cart", async (req, res) => {
    try {
        const userId = req.query.userId; // Note: Gi·∫£ ƒë·ªãnh userId ƒë∆∞·ª£c g·ª≠i qua query (c√≥ th·ªÉ thay b·∫±ng header n·∫øu d√πng token)
        if (!userId) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId is required"
            });
        }
        const cartItems = await winsnackCollection.find({ userId }).toArray();
        res.json({
            success: true,
            data: cartItems
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch cart",
            error: error.toString()
        });
    }
});


// Note: Th√™m endpoint ƒë·ªÉ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng
app.post("/cart/add", async (req, res) => {     
    try {         
        const { userId, productId, quantity, unit_price } = req.body;         
        if (!userId || !productId || !quantity || !unit_price) {             
            return res.status(400).json({                 
                success: false,                 
                message: "‚ùå userId, productId, quantity, and unit_price are required"             
            });         
        }           

        // Note: Ki·ªÉm tra s·∫£n ph·∫©m c√≥ t·ªìn t·∫°i kh√¥ng         
        const product = await productsCollection.findOne({ _id: new ObjectId(productId) });         
        if (!product) {             
            return res.status(404).json({                 
                success: false,                 
                message: "‚ùå Product not found"             
            });         
        }           

        // Note: Ki·ªÉm tra xem s·∫£n ph·∫©m ƒë√£ c√≥ trong gi·ªè h√†ng ch∆∞a         
        const existingItem = await winsnackCollection.findOne({ userId, productId });         
        if (existingItem) {             
            // N·∫øu ƒë√£ c√≥, tƒÉng s·ªë l∆∞·ª£ng             
            await winsnackCollection.updateOne(
                { userId, productId },                 
                { $inc: { quantity } }             
            );         
        } else {             
            // N·∫øu ch∆∞a c√≥, th√™m m·ªõi             
            await winsnackCollection.insertOne({                 
                userId,                 
                productId,                 
                quantity,                 
                unit_price,                 
                product_name: product.title || "Unknown", // Note: L·∫•y t·ª´ product n·∫øu c√≥                 
                image_1: product.image_1 || "", // Note: L·∫•y t·ª´ product n·∫øu c√≥                 
                stocked_quantity: product.stocked_quantity || 0 // Note: L·∫•y t·ª´ product n·∫øu c√≥             
            });         
        }           

        res.json({ // S·ª≠a l·ªói d·∫•u ngo·∫∑c
            success: true,             
            message: "‚úÖ Product added to cart"         
        });     
    } catch (error) {         
        res.status(500).json({             
            success: false,             
            message: "‚ùå Failed to add to cart",             
            error: error.toString()         
        });     
    } 
});




// Note: Th√™m endpoint ƒë·ªÉ x√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng
app.delete("/cart/remove/:productId", async (req, res) => {
    try {
        const { productId } = req.params;
        const userId = req.query.userId; // Note: Gi·∫£ ƒë·ªãnh userId qua query
        if (!userId || !productId) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId and productId are required"
            });
        }


        const result = await winsnackCollection.deleteOne({ userId, productId });
        if (result.deletedCount === 0) {
            return res.status(404).json({
                success: false,
                message: "‚ùå Item not found in cart"
            });
        }


        res.json({
            success: true,
            message: "‚úÖ Product removed from cart"
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to remove from cart",
            error: error.toString()
        });
    }
});


// Note: Th√™m endpoint ƒë·ªÉ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m trong gi·ªè h√†ng
app.patch("/cart/update", async (req, res) => {
    try {
        const { userId, productId, quantity } = req.body;
        if (!userId || !productId || !quantity) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId, productId, and quantity are required"
            });
        }


        const result = await winsnackCollection.updateOne(
            { userId, productId },
            { $set: { quantity } }
        );


        if (result.matchedCount === 0) {
            return res.status(404).json({
                success: false,
                message: "‚ùå Item not found in cart"
            });
        }


        res.json({
            success: true,
            message: "‚úÖ Quantity updated"
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to update quantity",
            error: error.toString()
        });
    }
});


// Note: Th√™m endpoint ƒë·ªÉ c·∫≠p nh·∫≠t to√†n b·ªô gi·ªè h√†ng
app.put("/cart/update-all", async (req, res) => {
    try {
        const { userId, items } = req.body;
        if (!userId || !items || !Array.isArray(items)) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId and items (array) are required"
            });
        }


        // Note: X√≥a to√†n b·ªô gi·ªè h√†ng hi·ªán t·∫°i c·ªßa user v√† thay b·∫±ng danh s√°ch m·ªõi
        await winsnackCollection.deleteMany({ userId });
        if (items.length > 0) {
            await winsnackCollection.insertMany(
                items.map(item => ({
                    userId,
                    productId: item.productId,
                    quantity: item.quantity,
                    unit_price: item.unit_price
                }))
            );
        }


        res.json({
            success: true,
            message: "‚úÖ Cart updated"
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to update cart",
            error: error.toString()
        });
    }
});


// Note: Th√™m endpoint ƒë·ªÉ l∆∞u c√°c s·∫£n ph·∫©m ƒë√£ ch·ªçn
app.post("/cart/saveSelectedItems", async (req, res) => {
    try {
        const { userId, selectedItems } = req.body;
        if (!userId || !selectedItems || !Array.isArray(selectedItems)) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId and selectedItems (array) are required"
            });
        }


        // Note: ƒê√¢y l√† n∆°i b·∫°n c√≥ th·ªÉ l∆∞u selectedItems v√†o m·ªôt collection kh√°c ho·∫∑c x·ª≠ l√Ω t√πy √Ω
        // V√≠ d·ª•: Ch·ªâ tr·∫£ v·ªÅ th√¥ng b√°o th√†nh c√¥ng
        res.json({
            success: true,
            message: "‚úÖ Selected items saved"
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to save selected items",
            error: error.toString()
        });
    }
});


// Note: Th√™m endpoint ƒë·ªÉ x√≥a to√†n b·ªô gi·ªè h√†ng
app.delete("/cart/clear", async (req, res) => {
    try {
        const userId = req.query.userId; // Note: Gi·∫£ ƒë·ªãnh userId qua query
        if (!userId) {
            return res.status(400).json({
                success: false,
                message: "‚ùå userId is required"
            });
        }


        await winsnackCollection.deleteMany({ userId });
        res.json({
            success: true,
            message: "‚úÖ Cart cleared"
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to clear cart",
            error: error.toString()
        });
    }
});






// Th√™m v√†o file index.js
const ordersCollection = database.collection("Order");


app.post('/orders/create', async (req, res) => {
    try {
        const orderData = req.body;
        // ƒê·∫£m b·∫£o createdAt l√† m·ªôt Date object n·∫øu ch∆∞a ph·∫£i
        if (typeof orderData.createdAt === 'string') {
            orderData.createdAt = new Date(orderData.createdAt);
        }
       
        // Th√™m timestamp v√† tr·∫°ng th√°i ƒë∆°n h√†ng
        orderData.createdAt = new Date();
        orderData.status = 'Pending';


        const result = await ordersCollection.insertOne(orderData);
       
        res.status(201).json({
            orderId: result.insertedId,
            status: 'Pending',
            message: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng"
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói t·∫°o ƒë∆°n h√†ng",
            error: error.toString()
        });
    }
});


app.get('/orders/details/:orderId', async (req, res) => {
    try {
        const orderId = req.params.orderId;
        const order = await ordersCollection.findOne({
            oderId: orderId
        });
       
        res.json(order);
    } catch (error) {
        res.status(500).json({
            message: "L·ªói l·∫•y chi ti·∫øt ƒë∆°n h√†ng",
            error: error.toString()
        });
    }
});


app.get('/orders/history', async (req, res) => {
    try {
        const userId = req.query.userId;
        const orders = await ordersCollection
            .find({ 'address.userId': userId })
            .sort({ createdAt: -1 })
            .toArray();
       
        res.json(orders);
    } catch (error) {
        res.status(500).json({
            message: "L·ªói l·∫•y l·ªãch s·ª≠ ƒë∆°n h√†ng",
            error: error.toString()
        });
    }
});


app.patch('/orders/cancel/:orderId', async (req, res) => {
    try {
        const orderId = req.params.orderId;
        const result = await ordersCollection.findOneAndUpdate(
            { oderId: orderId },
            { $set: { status: 'Cancelled' } },
            { returnDocument: 'after' }
        );
       
        res.json({
            orderId: result.oderId,
            status: 'Cancelled',
            message: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c h·ªßy"
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói h·ªßy ƒë∆°n h√†ng",
            error: error.toString()
        });
    }
});






// Endpoint l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng
app.get("/order", async (req, res) => {
    try {
        const orders = await orderCollection.find({}).toArray();
        res.json({
            success: true,
            data: orders,
            count: orders.length
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch orders",
            error: error.toString()
        });
    }
});


// Endpoint l·∫•y ƒë∆°n h√†ng theo userId - ƒê·∫∂T TR∆Ø·ªöC endpoint l·∫•y theo ID
app.get("/order/user/:userId", async (req, res) => {
    try {
        const { userId } = req.params;
        const orders = await orderCollection.find({ userId: userId }).toArray();
       
        res.json({
            success: true,
            orders: orders,
            hasOrders: orders.length > 0
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch user orders",
            error: error.toString()
        });
    }
});


// Endpoint l·∫•y chi ti·∫øt ƒë∆°n h√†ng theo ID - ƒê·∫∂T SAU endpoint l·∫•y theo userId
app.get("/order/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const order = await orderCollection.findOne({ _id: new ObjectId(id) });
       
        if (!order) {
            return res.status(404).json({
                success: false,
                message: "‚ùå Order not found"
            });
        }
       
        res.json({
            success: true,
            data: order
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "‚ùå Failed to fetch order",
            error: error.toString()
        });
    }
});


app.post("/login", async (req, res) => {
    const { profileName, password } = req.body;


    try {
        const user = await database.collection("User").findOne({ profileName, password });


        if (!user) {
            return res.status(401).json({
                success: false,
                message: "T√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u kh√¥ng ƒë√∫ng."
            });
        }


        res.json({
            success: true,
            message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!",
            user: {
                profileName: user.profileName,
                role: user.role,
                userId: user.userId
            }
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "L·ªói m√°y ch·ªß",
            error: error.toString()
        });
    }
});


app.post('/auth/login', async (req, res) => {
    const { profileName, password } = req.body;
    const user = await database.collection('User').findOne({ profileName });


    if (!user || user.password !== password) {
        return res.status(401).json({ message: "Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u" });
    }


    res.json({
        user: {
            userId: user.userId,
            profileName: user.profileName,
            role: user.role,
            email: user.email
        }
    });
});




app.get('/profile', async (req, res) => {
    try {
        const userId = req.query.userId; // L·∫•y userId t·ª´ query ho·∫∑c header


        if (!userId) {
            return res.status(400).json({ message: "Thi·∫øu userId" });
        }


        const user = await database.collection('User').findOne({ userId });


        if (!user) {
            return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
        }


        res.json({
            userId: user.userId,
            profileName: user.profileName,
            email: user.email,
            role: user.role,
            phone: user.phone,
            address: user.address,
            marketing: user.marketing
        });
       
    } catch (error) {
        res.status(500).json({ message: "L·ªói server", error: error.toString() });
    }
});


// Th√™m v√†o file index.js
app.post("/register", async (req, res) => {
    const { profileName, password } = req.body;


    try {
        // Ki·ªÉm tra profileName ƒë√£ t·ªìn t·∫°i ch∆∞a
        const existingUser = await database.collection("User").findOne({ profileName });
       
        if (existingUser) {
            return res.status(400).json({
                success: false,
                message: "T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i."
            });
        }


        // T·∫°o userId m·ªõi
        const userId = new ObjectId().toString();
       
        // T·∫°o user m·ªõi
        const newUser = {
            userId,
            profileName,
            password,
            email: "",
            gender: "",
            birthDate: {
                day: "",
                month: "",
                year: ""
            },
            marketing: false,
            phone: "",
            address: "",
            role: "user",
            action: "just view"
        };


        // L∆∞u user v√†o database
        const result = await database.collection("User").insertOne(newUser);


        // Tr·∫£ v·ªÅ th√¥ng tin user (kh√¥ng bao g·ªìm password)
        const { password: _, ...userWithoutPassword } = newUser;
       
        res.status(201).json({
            success: true,
            message: "ƒêƒÉng k√Ω th√†nh c√¥ng!",
            user: userWithoutPassword
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: "L·ªói ƒëƒÉng k√Ω t√†i kho·∫£n",
            error: error.toString()
        });
    }
});


// Thay ƒë·ªïi endpoint update-profile
app.put('/update-profile', async (req, res) => {
    try {
      const updatedData = req.body;
      const userId = updatedData.userId; // L·∫•y userId tr·ª±c ti·∫øp t·ª´ body request
     
      console.log('Received update request:', updatedData);
     
      // Ki·ªÉm tra xem userId c√≥ ƒë∆∞·ª£c cung c·∫•p kh√¥ng
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: 'Thi·∫øu userId trong y√™u c·∫ßu'
        });
      }
     
      const result = await database.collection('User').findOneAndUpdate(
        { userId: userId },
        { $set: {
          profileName: updatedData.profileName,
          email: updatedData.email,
          phone: updatedData.phone,
          address: updatedData.address,
          marketing: updatedData.marketing
        }},
        { returnDocument: 'after' }
      );
     
      if (!result) {
        console.error('User not found for userId:', userId);
        return res.status(404).json({
          success: false,
          message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'
        });
      }
     
      console.log('Result before sending response:', result);
        return res.status(200).json({
        success: true,
        message: 'C·∫≠p nh·∫≠t th√¥ng tin th√†nh c√¥ng',
        user: result.value
        });
    } catch (error) {
      console.error('L·ªói khi c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng:', error);
      return res.status(500).json({
        success: false,
        message: 'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng'
      });
    }
  });


  // ‚úÖ Endpoint l·∫•y th√¥ng tin ng∆∞·ªùi d√πng m·ªõi nh·∫•t theo userId
app.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;


    try {
        const user = await database.collection("User").findOne({ userId });


        if (!user) {
            return res.status(404).json({
                success: false,
                message: 'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng'
            });
        }


        res.json({
            success: true,
            user
        });
    } catch (error) {
        console.error('‚ùå L·ªói l·∫•y th√¥ng tin ng∆∞·ªùi d√πng:', error);
        res.status(500).json({
            success: false,
            message: 'L·ªói server',
            error: error.toString()
        });
    }
});


// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: function(req, file, cb) {
      const uploadDir = 'public/uploads/avatars';
      // Create directory if it doesn't exist
      if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
      }
      cb(null, uploadDir);
    },
    filename: function(req, file, cb) {
      // Create unique filename: userId + timestamp + original extension
      const fileExt = path.extname(file.originalname);
      const fileName = `${req.body.userId}-${Date.now()}${fileExt}`;
      cb(null, fileName);
    }
  });
 
  // File filter to only allow image files
  const fileFilter = (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file h√¨nh ·∫£nh!'), false);
    }
  };
 
  const upload = multer({
    storage: storage,
    limits: {
      fileSize: 2 * 1024 * 1024 // 2MB limit
    },
    fileFilter: fileFilter
  });
 
  // Avatar upload endpoint
  app.post('/upload-avatar', upload.single('avatar'), async (req, res) => {
    try {
      const userId = req.body.userId;
      if (!req.file || !userId) {
        return res.status(400).json({ success: false, message: 'Thi·∫øu file ho·∫∑c userId' });
      }
 
      const avatarUrl = `/uploads/avatars/${req.file.filename}`;
 
      const result = await usersCollection.findOneAndUpdate(
        { userId: userId },
        { $set: { avatar: avatarUrl } },
        { returnDocument: 'after' }
      );
 
      if (!result.value) {
        return res.status(404).json({ success: false, message: 'Kh√¥ng t√¨m th·∫•y user' });
      }
 
      res.status(200).json({
        success: true,
        message: 'C·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán th√†nh c√¥ng',
        user: result.value
      });
    } catch (error) {
      console.error('Error uploading avatar:', error);
      res.status(500).json({ success: false, message: 'L·ªói server: ' + error.message });
    }
  });  
 
  // Serve static files
  app.use('/uploads/avatars', express.static('public/uploads/avatars'));
 
  app.put('/update-password', async (req, res) => {
    try {
      const { userId, newPassword } = req.body;
      if (!userId || !newPassword) {
        return res.status(400).json({ success: false, message: "Thi·∫øu userId ho·∫∑c newPassword" });
      }
  
      const result = await database.collection('User').findOneAndUpdate(
        { userId },
        { $set: { password: newPassword } },
        { returnDocument: 'after' }
      );
  
      if (!result.value) {
        return res.status(404).json({ success: false, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
      }
  
      res.json({ success: true, message: "C·∫≠p nh·∫≠t m·∫≠t kh·∫©u th√†nh c√¥ng" });
    } catch (error) {
      console.error('Error in /update-password:', error);
      res.status(500).json({ success: false, message: "L·ªói server", error: error.toString() });
    }
  });

  app.get('/profile-admin', async (req, res) => {
    try {
        const userId = req.query.userId;
        console.log('Fetching profile for userId:', userId);
    
        if (!userId) {
          return res.status(400).json({ success: false, message: "Thi·∫øu userId" });
        }
    
        const user = await database.collection('User').findOne({ userId });
        if (!user) {
          console.log('User not found for userId:', userId);
          return res.status(404).json({ success: false, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng" });
        }
        res.json({
          success: true,
          user: {
            userId: user.userId,
            profileName: user.profileName,
            email: user.email,
            role: user.role,
            phone: user.phone || '',
            avatar: user.avatar || '',
            address: user.address || '',
            marketing: user.marketing || false
          }
        });
      } catch (error) {
        console.error('Error in /profile:', error);
        res.status(500).json({ success: false, message: "L·ªói server", error: error.toString() });
      }
    });

    // Endpoint upload avatar
app.post('/upload-avatar-admin', upload.single('avatar'), async (req, res) => {
    try {
        console.log('Received upload request - userId:', req.body.userId);
        console.log('Uploaded file:', req.file);

        const userId = req.body.userId;
        if (!req.file || !userId) {
            return res.status(400).json({ success: false, message: 'Thi·∫øu file ho·∫∑c userId' });
        }

        const avatarUrl = `/uploads/avatars/${req.file.filename}`;
        console.log('Generated avatar URL:', avatarUrl);

        const result = await usersCollection.findOneAndUpdate(
            { userId: userId },
            { $set: { avatar: avatarUrl } },
            { returnDocument: 'after' }
        );

        if (!result.value) {
            return res.status(404).json({ success: false, message: 'Kh√¥ng t√¨m th·∫•y user' });
        }

        res.status(200).json({
            success: true,
            message: 'C·∫≠p nh·∫≠t ·∫£nh ƒë·∫°i di·ªán th√†nh c√¥ng',
            user: result.value
        });
    } catch (error) {
        console.error('Error uploading avatar:', error);
        res.status(500).json({ success: false, message: 'L·ªói server: ' + error.message });
    }
});

app.get('/get-avatar/:userId', async (req, res) => {
    try {
        const { userId } = req.params;

        const user = await usersCollection.findOne({ userId });
        if (!user || !user.avatar) {
            return res.status(404).json({ message: 'Avatar not found' });
        }

        const filePath = path.join(__dirname, 'public', user.avatar);
        res.sendFile(filePath);
    } catch (error) {
        res.status(500).json({ message: 'Server error', error: error.toString() });
    }
});


// API l·∫•y danh s√°ch kh√°ch h√†ng (users c√≥ role='user')
app.get("/api/customers", async (req, res) => {
    try {
      const users = await usersCollection.find({ role: 'user' }).toArray();
  
      const enhancedUsers = await Promise.all(users.map(async (user) => {
        const orderCount = await orderCollection.countDocuments({ userId: user.userId });
        return {
          _id: user._id,
          userId: user.userId,
          profileName: user.profileName,
          email: user.email,
          phone: user.phone || 'Ch∆∞a cung c·∫•p',
          address: user.address || 'Ch∆∞a cung c·∫•p',
          orderCount: orderCount // T√≠nh t·ª´ Order
        };
      }));
  
      return res.status(200).json({
        success: true,
        data: enhancedUsers,
        message: 'L·∫•y danh s√°ch kh√°ch h√†ng th√†nh c√¥ng'
      });
    } catch (error) {
      console.error('Error fetching customers:', error);
      return res.status(500).json({
        success: false,
        message: 'L·ªói server khi l·∫•y danh s√°ch kh√°ch h√†ng',
        error: error.message
      });
    }
  });

// API t√¨m ki·∫øm kh√°ch h√†ng theo t·ª´ kh√≥a v√† lo·∫°i t√¨m ki·∫øm
app.get("/api/search-user", async (req, res) => {
  try {
    const { searchTerm, searchType } = req.query;
    let query = { role: 'user' };
    
    // X√¢y d·ª±ng query d·ª±a tr√™n lo·∫°i t√¨m ki·∫øm
    if (searchTerm && searchType !== 'all') {
      switch (searchType) {
        case 'name':
          query.profileName = { $regex: searchTerm, $options: 'i' };
          break;
        case 'email':
          query.email = { $regex: searchTerm, $options: 'i' };
          break;
        case 'phone':
          query.phone = { $regex: searchTerm, $options: 'i' };
          break;
        case 'address':
          query.address = { $regex: searchTerm, $options: 'i' };
          break;
        case 'orderCount':
          // Tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát - x·ª≠ l√Ω ri√™ng ·ªü d∆∞·ªõi
          break;
      }
    } else if (searchTerm) {
      // T√¨m ki·∫øm t·∫•t c·∫£ c√°c tr∆∞·ªùng
      query.$or = [
        { profileName: { $regex: searchTerm, $options: 'i' } },
        { email: { $regex: searchTerm, $options: 'i' } },
        { phone: { $regex: searchTerm, $options: 'i' } },
        { address: { $regex: searchTerm, $options: 'i' } }
      ];
    }
    
    // T√¨m c√°c user ph√π h·ª£p v·ªõi query
    const users = await usersCollection.find(query).toArray();
    
    // L·∫•y th√¥ng tin ƒë∆°n h√†ng cho m·ªói user
    let enhancedUsers = await Promise.all(users.map(async (user) => {
      const orderCount = await orderCollection.countDocuments({ userId: user.userId });
      
      return {
        _id: user._id,
        userId: user.userId,
        profileName: user.profileName,
        email: user.email,
        phone: user.phone || 'Ch∆∞a cung c·∫•p',
        address: user.address || 'Ch∆∞a cung c·∫•p',
        orderCount: orderCount
      };
    }));
    
    // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p t√¨m ki·∫øm theo orderCount
    if (searchTerm && searchType === 'orderCount') {
      enhancedUsers = enhancedUsers.filter(user => 
        user.orderCount.toString().includes(searchTerm)
      );
    }
    
    return res.status(200).json({
      success: true,
      data: enhancedUsers,
      message: 'T√¨m ki·∫øm kh√°ch h√†ng th√†nh c√¥ng'
    });
  } catch (error) {
    console.error('Error searching customers:', error);
    return res.status(500).json({
      success: false,
      message: 'L·ªói server khi t√¨m ki·∫øm kh√°ch h√†ng',
      error: error.message
    });
  }
});

// Endpoint l·∫•y danh s√°ch ƒë∆°n h√†ng cho admin
app.get('/api/order-admin', async (req, res) => {
    try {
      const orders = await orderCollection.find({}).toArray();
      return res.status(200).json({
        success: true,
        data: orders,
        message: 'L·∫•y danh s√°ch ƒë∆°n h√†ng th√†nh c√¥ng'
      });
    } catch (error) {
      console.error('Error fetching orders:', error);
      return res.status(500).json({
        success: false,
        message: 'L·ªói server khi l·∫•y danh s√°ch ƒë∆°n h√†ng',
        error: error.message
      });
    }
  });
  
  // Endpoint l·∫•y chi ti·∫øt ƒë∆°n h√†ng theo orderId
  app.get('/api/order-detail-admin/:orderId', async (req, res) => {
    try {
      const { orderId } = req.params;
      const order = await orderCollection.findOne({ orderId });
      if (!order) {
        return res.status(404).json({
          success: false,
          message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng'
        });
      }
  
      // L·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ collection User (n·∫øu c·∫ßn)
      const user = await usersCollection.findOne({ userId: order.userId });
      if (user) {
        order.userName = user.profileName || 'Kh√°ch v√£ng lai';
        if (!order.contact) {
          order.contact = {
            name: user.profileName || 'Ch∆∞a cung c·∫•p',
            address: user.address || 'Ch∆∞a cung c·∫•p',
            phone: user.phone || 'Ch∆∞a cung c·∫•p'
          };
        }
      }
  
      return res.status(200).json({
        success: true,
        data: order,
        message: 'L·∫•y chi ti·∫øt ƒë∆°n h√†ng th√†nh c√¥ng'
      });
    } catch (error) {
      console.error('Error fetching order detail:', error);
      return res.status(500).json({
        success: false,
        message: 'L·ªói server khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng',
        error: error.message
      });
    }
  });

// Kh·ªüi ƒë·ªông server
app.listen(port, () => {
    console.log(`üöÄ Server is running at http://localhost:${port}`);
});